
import React,{useEffect,useRef} from 'react';
export default function AnimatedBackground(){const ref=useRef(null);useEffect(()=>{const canvas=ref.current;const ctx=canvas.getContext('2d');let w=canvas.width=window.innerWidth;let h=canvas.height=window.innerHeight;function onResize(){w=canvas.width=window.innerWidth;h=canvas.height=window.innerHeight}window.addEventListener('resize',onResize);const dots=Array.from({length:180},()=>({x:Math.random()*w,y:Math.random()*h,vx:(Math.random()-0.5)*0.6,vy:(Math.random()-0.5)*0.6,r:Math.random()*1.6+0.5}));let mx=0,my=0;function onMove(e){mx=e.clientX;my=e.clientY}window.addEventListener('mousemove',onMove);function draw(){ctx.clearRect(0,0,w,h);const grad=ctx.createLinearGradient(0,0,w,h);grad.addColorStop(0,'#020617');grad.addColorStop(1,'#0b1220');ctx.fillStyle=grad;ctx.fillRect(0,0,w,h);ctx.strokeStyle='rgba(148,163,184,0.04)';for(let x=0;x<w;x+=100){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,h);ctx.stroke()}for(let y=0;y<h;y+=100){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(w,y);ctx.stroke()}for(const d of dots){d.x+=d.vx+(mx-w/2)*0.00004;d.y+=d.vy+(my-h/2)*0.00004;if(d.x<0||d.x>w)d.vx*=-1;if(d.y<0||d.y>h)d.vy*=-1;ctx.beginPath();ctx.arc(d.x,d.y,d.r,0,Math.PI*2);ctx.fillStyle='rgba(34,211,238,0.5)';ctx.shadowColor='rgba(34,211,238,0.3)';ctx.shadowBlur=8;ctx.fill();ctx.shadowBlur=0}for(let i=0;i<dots.length;i++){for(let j=i+1;j<dots.length;j++){const a=dots[i],b=dots[j];const dx=a.x-b.x,dy=a.y-b.y,dist=Math.sqrt(dx*dx+dy*dy);if(dist<110){ctx.strokeStyle=`rgba(34,211,238,${(1-dist/110)*0.22})`;ctx.beginPath();ctx.moveTo(a.x,a.y);ctx.lineTo(b.x,b.y);ctx.stroke()}}}requestAnimationFrame(draw)}draw();return ()=>{window.removeEventListener('resize',onResize);window.removeEventListener('mousemove',onMove)}},[]);return <canvas ref={ref} className="fixed inset-0 -z-10"/>;}